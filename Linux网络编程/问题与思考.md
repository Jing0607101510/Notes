# 关于套接字阻塞或者非阻塞

- 阻塞或者非阻塞是对于文件来说的，而不是对于read、write的操作来说的。所以在非阻塞的listenfd中调用accept，如果没有连接的客户端，那么accept返回-1，设置errno为EAGAIN、EWOULDBLOCK
- epoll只能是设置边缘触发还是水平触发，并不能改变文件描述符是阻塞的还是非阻塞的。
- **监听套接字最好设置为非阻塞+epoll水平触发**，原因如下
  - 使用非阻塞
    - 客户通过connect向TCP服务器发起三次握手
    - 三次握手完成后，触发TCP服务器监听套接字的可读事件，IO复用返回（select、poll、epoll_wait）
    - 客户通过RST报文取消连接
    - TCP服务器调用accept接受连接，此时发现内核已连接队列为空（因为唯一的连接已被客户端取消）
    - 程序阻塞在accept调用，无法响应其它已连接套接字的事件
  - 使用水平触发
    - 如果同时有多个连接建立，监听队列由空变为非空，EPOLLIN事件被触发，那么accept一次只能接受一个连接，如果使用水平触发，那么后续在监听队列中未被接受的连接触发EPOLLIN事件。如果使用边缘触发，那么剩下的连接不能触发EPOLLIN事件，导致不能接收这些连接。
    - 当然可以使用边缘触发，但是需要while循环调用accept，直到监听队列为空（边缘触发，一次性读取所有数据）





# 关于epoll

- LT模式下，读事件触发后，可以按照需要收取想要的字节数，不要把本次收到的数据全部读取。ET模式下，读事件必须把数据全部读取（循环读取），因为不一定有下一次机会有新的数据来，这样造成剩下的数据没有读取。除此之外，上一次没有读完的数据没有及时处理，造成客户端相应延迟。
- LT模式下，不要的写事件一定要即时移除，避免不必要的触发。ET模式下，如果写事件触发后，如果还需要下一次的写事件触发，需要继续注册一次检测可写事件。
- LT模式下，EPOLLIN触发条件
  - socket读缓冲区没有数据==》读缓冲区有数据
  - 读缓冲区有数据
- LT模式下，EPOLLOUT触发条件
  - socket写缓冲区满==》写缓冲非满
  - socket写缓冲非满
- ET模式下，EPOLLIN触发条件
  - socket读缓冲区没有数据==》读缓冲区有数据
  - socket又来了新的数据
- ET模式下，EPOLLOUT触发条件
  - socket写缓冲区满==》写缓冲非满
  - 重新注册可写事件
  - 连接建立并accept后

- ET模式下，epoll_wait返回，在处理的过程中新的数据到来。然后再一次调用epoll_wait会触发EPOLLIN吗？





# 为什么ET模式的epoll需要用非阻塞的IO

因为使用ET模式的话，对于读事件，需要一次性把数据读取

- 为什么需要把数据一次性读取
  - 接收端接收完整的数据后会向对端发送应答报文，对端才会继续向接收端发送数据，从而触发下一次的EPOLLIN，而这时没有读完socket缓冲区中的所有数据，导致接收端无法向对端发送应答报文，而对端没有收到应答报文，也就不会再发送数据触发下一次的EPOLLIN，而没有下一次的EPOLLIN事件，接收端也就永远不知道此socket缓冲区中还有未读出的数据&oq=接收端接收完整的数据后会向对端发送应答报文，对端才会继续向接收端发送数据，从而触发下一次的EPOLLIN，而这时没有读完socket缓冲区中的所有数据，导致接收端无法向对端发送应答报文，而对端没有收到应答报文，也就不会再发送数据触发下一次的EPOLLIN，而没有下一次的EPOLLIN事件，接收端也就永远不知道此socket缓冲区中还有未读出的数据

一次性读取所有的数据的话，就要使用while读取所有的数据。当读取完所有的数据之后，如果使用的是阻塞的IO，那么继续调用recv就会阻塞。所以使用非阻塞的IO，当返回-1，errno为EAGAIN或者EWOULDBLOCK时，就知道已经读取完数据，不会阻塞。







