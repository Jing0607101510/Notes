# gdb和makefile

用于调试逻辑错误。编译时使用``-g``参数

## 基本指令

- ``list或l n `` 从第n行开始列出代码
- ``b n`` 在第n行代码设置断点， 这一行并没有并执行 ``b n if var条件``条件断点
- ``run/r`` 执行程序到断点之前
- ``next/n`` 执行下一条指令，并不进入函数
- ``step/s`` 执行下一条指令，会进入函数
- ``continue/c`` 继续执行断点后续代码，直到遇到下一个断点或者程序运行结束。
- ``quit/q`` 退出gdb调试
- ``print/p 变量名 `` 打印变量的值 （打印当前栈帧的变量）
- ``start`` 单步执行，运行程序，然后停在第一行执行语句（第一行语句还没有被执行）
- ``finish`` 结束当前函数，返回到函数调用点

## 其他指令

- 使用``run``找到段错误位置
- ``set args``设置运行参数
- ``run arg1 arg2 arg3 ...`` 设置运行参数
- ``start arg1 arg2 ...``设置运行时参数
- ``delete \ d`` 删除断点
- ``info b  \ i b`` 查看设置的断点的信息表，``info``查看GDB内部局部变量的信息
- ``ptype var``查看变量var的类型
- ``backtrace \ bt`` 查看函数的调用的栈帧和层级关系
- ``frame``切换函数的栈帧
  - 栈帧在函数被调用时在栈中被开辟，用于存储函数的局部变量和临时值。
- ``display`` 设置单步调试、运行时跟踪的变量
- ``undisplay`` 取消跟踪变量
- ``p *数组名@10`` 列出数组前十个元素
- ``p 数组名[n]@m`` 列出从下标n开始的m个元素
- ``info locals``  列出局部变量





## makefile

### makefile工作原理

#### 命名规则

makefile   或者  Makefile

#为注释

makefile可以是其他名字，使用时``make -f xxx.mk``

#### 1个规则

- 若要生成目标，检查规则中的依赖条件是否存在，如果不存在，则寻找是否有规则生成该依赖文件。
- 检查规则中的目标是否需要更新，必须先要检查它所有的依赖，依赖中有一个被更新，则目标必须更新。
- 规则格式：

```shell
a.out:a.o
	gcc a.o -o a.out
	
目标:依赖条件
	命令(命令可以有多条)
```

- 依赖关系自底向上

- 通过比较目标和依赖的修改时间，如果目标的修改时间早于依赖的修改时间，那么就需要更新。

- 如果目标不依赖任何条件，则执行对应的操作，以示更新。（clean）

- makefile默认将第一条规则的目标作为终极目标，只要终极目标满足了，剩下的规则不进行了。

- 可以通过``ALL:目标``修改终极目标

- ``make 目标`` 只要某个目标；``make 目标 -n``模拟执行，打印规则的命令，实际没有执行

- ```shell
  clean:
  	-rm xx.o xx.o
  ```

  %目标为clean，不依赖于条件，那么只执行命令。rm命令前面加-，表示如果出错，继续执行。

#### 2个函数

- ``src=$(wildcard ./*.c)`` 匹配当前目录下的所有.c文件，将文件名组成文件列表，赋值给src
- ``obj=$(patsubst %.c, %.o, $(src))`` 将src文件列表中的文件名中的.c替换为.o，然后赋值给obj
- 得到的结果是一个列表

#### 3个自动变量

- ``$@`` 表示规则中的目标，用在规则的命令中
- ``$^`` 表示规则中的所有依赖条件，用在规则的命令中
- ``$<`` 表示规则中的第一个依赖条件，用在规则的命令中。并且可以在模式规则中使用。

#### 模式规则

相当于将多个相似的指令，以“通配符”的形式统一起来。

这里代表的是“一个对一个”，而不是列表

```C++
%.o:%.c
    gcc -c $< -o $@
```

#### 静态模式规则

当某个依赖条件作为另一个规则的目标时，而且有作为多个规则的目标时，为了去除二义性，可以使用静态模式规则，指定应该执行哪一条规则。

```shell
$(obj):%.o:%.c
	gcc -c $< -o $@
```

#### 伪目标

``.PHONY: clean ALL`` 将clean和ALL定为伪目标，而不是文件。否则如果目录中存在clean文件和ALL文件，那么会认为目标已经存在了。

#### 定义变量

```shell
varname=xxxx
$(varname) 取变量值
```

#### 库变量

- CC
- CPPFLAGS
- CFLAGS
- LDFLAGS

#### 匹配符

- *匹配0个或者多个字符
- %匹配多个或者0个字符，而且能够"锁定"这些字符，也就是同一个指令中，%所代表的值是一致的。